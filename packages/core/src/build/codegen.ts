import { resolve, relative } from 'node:path';
import { mkdir, writeFile } from 'node:fs/promises';
import type { ResolvedPackage } from '../types.js';
import type { BuildGroup } from './adapters/types.js';

/**
 * BuildGroup 用のアプリ統合コードを生成する。
 * .kagaribi/build/{name}/ に app.ts と clients.ts を出力する。
 */
export async function generateBuildCode(
  group: BuildGroup,
  projectRoot: string
): Promise<{ appPath: string }> {
  const outDir = resolve(projectRoot, '.kagaribi', 'build', group.host.name);
  await mkdir(outDir, { recursive: true });

  await Promise.all([
    generateBuildClients(outDir, projectRoot, group),
    generateBuildApp(outDir, projectRoot, group),
  ]);

  return { appPath: resolve(outDir, 'app.ts') };
}

/**
 * clients.ts: クライアント登録コードを生成する。
 */
async function generateBuildClients(
  outDir: string,
  projectRoot: string,
  group: BuildGroup
): Promise<void> {
  const lines: string[] = [
    '// Auto-generated by kagaribi. Do not edit.',
    "import { registerLocalClient, registerRemoteClient } from '@kagaribi/core';",
    '',
  ];

  // co-locateパッケージのimport + ローカル登録
  for (const pkg of group.colocated) {
    const importPath = toRelativeImport(outDir, resolve(pkg.path, 'src', 'index.ts'));
    const varName = toVarName(pkg.name);
    lines.push(`import ${varName}App from '${importPath}';`);
  }

  if (group.colocated.length > 0) {
    lines.push('');
  }

  for (const pkg of group.colocated) {
    const varName = toVarName(pkg.name);
    lines.push(
      `registerLocalClient({ name: '${pkg.name}', app: ${varName}App });`
    );
  }

  // リモートパッケージ登録
  for (const pkg of group.remotes) {
    const urlExpr = toUrlExpr(pkg);
    lines.push(
      `registerRemoteClient({ name: '${pkg.name}', url: ${urlExpr} });`
    );
  }

  lines.push('');

  await writeFile(resolve(outDir, 'clients.ts'), lines.join('\n'), 'utf-8');
}

/**
 * app.ts: 統合Honoアプリを生成する。
 * ホスト + co-locateパッケージをapp.route()でマウント、
 * リモートパッケージをproxyMiddlewareでプロキシ。
 */
async function generateBuildApp(
  outDir: string,
  projectRoot: string,
  group: BuildGroup
): Promise<void> {
  const lines: string[] = [
    '// Auto-generated by kagaribi. Do not edit.',
    "import { Hono } from 'hono';",
  ];

  // proxyMiddleware が必要な場合のみimport
  const hasRemotes = group.remotes.length > 0;
  if (hasRemotes) {
    lines.push("import { proxyMiddleware } from '@kagaribi/core';");
  }

  lines.push('');

  // clients.ts の副作用import
  lines.push("import './clients.js';");
  lines.push('');

  // ホストパッケージのimport
  const hostImport = toRelativeImport(
    outDir,
    resolve(group.host.path, 'src', 'index.ts')
  );
  lines.push(`import hostApp from '${hostImport}';`);

  // co-locateパッケージのimport
  for (const pkg of group.colocated) {
    const importPath = toRelativeImport(outDir, resolve(pkg.path, 'src', 'index.ts'));
    const varName = toVarName(pkg.name);
    lines.push(`import ${varName}App from '${importPath}';`);
  }

  lines.push('');
  lines.push('const app = new Hono();');
  lines.push('');

  // ホストマウント（rootパッケージは '/' にマウント）
  if (group.host.name === 'root') {
    lines.push("app.route('/', hostApp);");
  } else {
    lines.push(`app.route('/${group.host.name}', hostApp);`);
  }

  // co-locateパッケージのマウント
  // ネストルーティング対応: routesが指定されたパッケージを先にマウント
  const nestedPackages = group.colocated.filter(
    (p) => p.definition.routes && p.definition.routes.length > 0
  );
  const normalPackages = group.colocated.filter(
    (p) => !p.definition.routes || p.definition.routes.length === 0
  );

  // ネストルーティングパッケージ（より具体的なパスを先に）
  // co-locateなのでproxyMiddlewareではなく、パスパラメータ抽出 + app.request() でローカル転送
  for (const pkg of nestedPackages) {
    const varName = toVarName(pkg.name);
    for (const route of pkg.definition.routes ?? []) {
      const hasParams = route.includes(':');
      if (hasParams) {
        // パスパラメータを含むルート: ハンドラーで抽出して転送
        const paramNames = extractParamNames(route);
        const handlerName = `handle${capitalize(varName)}`;
        lines.push(`const ${handlerName} = async (c) => {`);
        lines.push(`  const params = {};`);
        for (const param of paramNames) {
          lines.push(`  params['${param}'] = c.req.param('${param}');`);
        }
        lines.push(`  const url = new URL(c.req.url);`);
        lines.push(`  const basePath = '${route}';`);
        lines.push(`  const basePattern = new RegExp('^' + basePath.replace(/:[^/]+/g, '[^/]+'));`);
        lines.push(`  const remaining = url.pathname.replace(basePattern, '') || '/';`);
        lines.push(`  const headers = new Headers(c.req.raw.headers);`);
        lines.push(`  headers.set('x-kagaribi-params', JSON.stringify(params));`);
        lines.push(`  const init = { method: c.req.method, headers };`);
        lines.push(`  if (c.req.method !== 'GET' && c.req.method !== 'HEAD') {`);
        lines.push(`    init.body = await c.req.raw.clone().arrayBuffer();`);
        lines.push(`  }`);
        lines.push(`  return ${varName}App.request(remaining + url.search, init);`);
        lines.push(`};`);
        lines.push(`app.all('${route}/*', ${handlerName});`);
        lines.push(`app.all('${route}', ${handlerName});`);
      } else {
        lines.push(`app.route('${route}', ${varName}App);`);
      }
    }
  }

  // 通常のco-locateパッケージ
  for (const pkg of normalPackages) {
    const varName = toVarName(pkg.name);
    lines.push(`app.route('/${pkg.name}', ${varName}App);`);
  }

  // リモートパッケージプロキシ
  for (const pkg of group.remotes) {
    const urlExpr = toUrlExpr(pkg);

    // ネストルーティング対応
    if (pkg.definition.routes && pkg.definition.routes.length > 0) {
      for (const route of pkg.definition.routes) {
        lines.push(
          `app.all('${route}/*', proxyMiddleware({ target: ${urlExpr}, basePath: '${route}' }));`
        );
        lines.push(
          `app.all('${route}', proxyMiddleware({ target: ${urlExpr}, basePath: '${route}' }));`
        );
      }
    } else {
      lines.push(
        `app.all('/${pkg.name}/*', proxyMiddleware({ target: ${urlExpr}, basePath: '/${pkg.name}' }));`
      );
    }
  }

  lines.push('');
  lines.push('export default app;');
  lines.push('');

  await writeFile(resolve(outDir, 'app.ts'), lines.join('\n'), 'utf-8');
}

/**
 * パッケージ名をJavaScript変数名に変換する。
 */
function toVarName(name: string): string {
  return name.replace(/-([a-z])/g, (_, c: string) => c.toUpperCase());
}

/**
 * 出力ディレクトリからソースファイルへの相対パスを生成する。
 */
function toRelativeImport(from: string, to: string): string {
  let rel = relative(from, to);
  rel = rel.replace(/\.ts$/, '.js');
  if (!rel.startsWith('.')) {
    rel = './' + rel;
  }
  return rel;
}

/**
 * ルートパターンからパスパラメータ名を抽出する。
 */
function extractParamNames(route: string): string[] {
  const params: string[] = [];
  route.replace(/:([^/]+)/g, (_, name: string) => {
    params.push(name);
    return '';
  });
  return params;
}

/**
 * 文字列の先頭を大文字にする。
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * パッケージURLの式を生成する。
 * $ENV_VAR形式の場合はprocess.envを参照するコードにする。
 */
function toUrlExpr(pkg: ResolvedPackage): string {
  const url = pkg.deploy.url ?? '';
  if (url.startsWith('$')) {
    return `process.env.${url.slice(1)}!`;
  }
  return `'${url}'`;
}
