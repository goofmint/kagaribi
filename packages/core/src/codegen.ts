import { resolve, relative, dirname } from 'node:path';
import { mkdir, writeFile } from 'node:fs/promises';
import type { ResolvedPackage } from './types.js';

/**
 * ビルド時コード生成: 解決済みパッケージ情報から
 * .kagaribi/generated/ 配下にクライアントコードとエントリポイントを生成する。
 */
export async function generateCode(
  projectRoot: string,
  packages: ResolvedPackage[]
): Promise<void> {
  const outDir = resolve(projectRoot, '.kagaribi', 'generated');
  await mkdir(outDir, { recursive: true });

  await Promise.all([
    generateClients(outDir, projectRoot, packages),
    generateEntry(outDir, projectRoot, packages),
  ]);
}

/**
 * clients.ts: 各パッケージのクライアント登録コードを生成する。
 */
async function generateClients(
  outDir: string,
  projectRoot: string,
  packages: ResolvedPackage[]
): Promise<void> {
  const lines: string[] = [
    '// Auto-generated by kagaribi. Do not edit.',
    "import { registerLocalClient, registerRemoteClient } from '@kagaribi/core';",
    '',
  ];

  // ローカルパッケージのimport文
  const localPackages = packages.filter(
    (p) => p.mode === 'local' && p.name !== 'root'
  );
  const remotePackages = packages.filter((p) => p.mode === 'remote');

  for (const pkg of localPackages) {
    const importPath = toRelativeImport(outDir, resolve(pkg.path, 'src', 'index.ts'));
    lines.push(
      `import ${toVarName(pkg.name)}App from '${importPath}';`
    );
  }

  if (localPackages.length > 0 || remotePackages.length > 0) {
    lines.push('');
  }

  // ローカルクライアント登録
  for (const pkg of localPackages) {
    lines.push(
      `registerLocalClient({ name: '${pkg.name}', app: ${toVarName(pkg.name)}App });`
    );
  }

  // リモートクライアント登録
  for (const pkg of remotePackages) {
    const url = pkg.deploy.url ?? '';
    const urlExpr = url.startsWith('$')
      ? `process.env.${url.slice(1)}!`
      : `'${url}'`;

    lines.push(
      `registerRemoteClient({ name: '${pkg.name}', url: ${urlExpr} });`
    );
  }

  lines.push('');

  const content = lines.join('\n');
  await writeFile(resolve(outDir, 'clients.ts'), content, 'utf-8');
}

/**
 * entry.ts: ルートHonoアプリのエントリポイントを生成する。
 * ローカルパッケージはapp.route()でマウント、
 * リモートパッケージはproxyMiddlewareでプロキシ。
 */
async function generateEntry(
  outDir: string,
  projectRoot: string,
  packages: ResolvedPackage[]
): Promise<void> {
  const lines: string[] = [
    '// Auto-generated by kagaribi. Do not edit.',
    "import { Hono } from 'hono';",
    "import { proxyMiddleware } from '@kagaribi/core';",
    '',
  ];

  // clientsの副作用import（クライアント登録を実行）
  lines.push("import './clients.js';");
  lines.push('');

  // パッケージのimport
  const rootPkg = packages.find((p) => p.name === 'root');
  const localPackages = packages.filter(
    (p) => p.mode === 'local' && p.name !== 'root'
  );
  const remotePackages = packages.filter((p) => p.mode === 'remote');

  if (rootPkg) {
    const importPath = toRelativeImport(outDir, resolve(rootPkg.path, 'src', 'index.ts'));
    lines.push(`import rootApp from '${importPath}';`);
  }

  for (const pkg of localPackages) {
    const importPath = toRelativeImport(outDir, resolve(pkg.path, 'src', 'index.ts'));
    lines.push(
      `import ${toVarName(pkg.name)}App from '${importPath}';`
    );
  }

  lines.push('');
  lines.push('const app = new Hono();');
  lines.push('');

  // rootマウント
  if (rootPkg) {
    lines.push("app.route('/', rootApp);");
  }

  // ローカルパッケージマウント
  for (const pkg of localPackages) {
    lines.push(
      `app.route('/${pkg.name}', ${toVarName(pkg.name)}App);`
    );
  }

  // リモートパッケージプロキシ
  for (const pkg of remotePackages) {
    const url = pkg.deploy.url ?? '';
    const urlExpr = url.startsWith('$')
      ? `process.env.${url.slice(1)}!`
      : `'${url}'`;

    lines.push(
      `app.all('/${pkg.name}/*', proxyMiddleware({ target: ${urlExpr} }));`
    );
  }

  lines.push('');
  lines.push('export default app;');
  lines.push('');

  const content = lines.join('\n');
  await writeFile(resolve(outDir, 'entry.ts'), content, 'utf-8');
}

/**
 * パッケージ名をJavaScript変数名に変換する。
 * ハイフンをキャメルケースに変換。
 */
function toVarName(name: string): string {
  return name.replace(/-([a-z])/g, (_, c: string) => c.toUpperCase());
}

/**
 * 出力ディレクトリからのソースファイルへの相対パスを生成する。
 * .ts拡張子を除去する。
 */
function toRelativeImport(from: string, to: string): string {
  let rel = relative(from, to);
  // .ts拡張子を除去
  rel = rel.replace(/\.ts$/, '.js');
  // 相対パスがドットで始まらない場合は追加
  if (!rel.startsWith('.')) {
    rel = './' + rel;
  }
  return rel;
}
